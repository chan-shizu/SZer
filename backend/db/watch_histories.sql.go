// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: watch_histories.sql

package db

import (
	"context"
	"time"
)

const getIncompleteWatchHistoryByUserAndProgram = `-- name: GetIncompleteWatchHistoryByUserAndProgram :one
SELECT id, user_id, program_id, position_seconds, is_completed, last_watched_at, created_at, updated_at
FROM watch_histories
WHERE user_id = $1 AND program_id = $2 AND is_completed = FALSE
`

type GetIncompleteWatchHistoryByUserAndProgramParams struct {
	UserID    string `json:"user_id"`
	ProgramID int64  `json:"program_id"`
}

func (q *Queries) GetIncompleteWatchHistoryByUserAndProgram(ctx context.Context, arg GetIncompleteWatchHistoryByUserAndProgramParams) (WatchHistory, error) {
	row := q.db.QueryRowContext(ctx, getIncompleteWatchHistoryByUserAndProgram, arg.UserID, arg.ProgramID)
	var i WatchHistory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProgramID,
		&i.PositionSeconds,
		&i.IsCompleted,
		&i.LastWatchedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertCompletedWatchHistory = `-- name: InsertCompletedWatchHistory :one
INSERT INTO watch_histories (
  user_id,
  program_id,
  position_seconds,
  is_completed,
  last_watched_at
)
VALUES ($1, $2, $3, TRUE, now())
RETURNING id, user_id, program_id, position_seconds, is_completed, last_watched_at, created_at, updated_at
`

type InsertCompletedWatchHistoryParams struct {
	UserID          string `json:"user_id"`
	ProgramID       int64  `json:"program_id"`
	PositionSeconds int32  `json:"position_seconds"`
}

func (q *Queries) InsertCompletedWatchHistory(ctx context.Context, arg InsertCompletedWatchHistoryParams) (WatchHistory, error) {
	row := q.db.QueryRowContext(ctx, insertCompletedWatchHistory, arg.UserID, arg.ProgramID, arg.PositionSeconds)
	var i WatchHistory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProgramID,
		&i.PositionSeconds,
		&i.IsCompleted,
		&i.LastWatchedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertIncompleteWatchHistory = `-- name: InsertIncompleteWatchHistory :one
INSERT INTO watch_histories (
  user_id,
  program_id,
  position_seconds,
  is_completed,
  last_watched_at
)
VALUES ($1, $2, $3, $4, now())
RETURNING id, user_id, program_id, position_seconds, is_completed, last_watched_at, created_at, updated_at
`

type InsertIncompleteWatchHistoryParams struct {
	UserID          string `json:"user_id"`
	ProgramID       int64  `json:"program_id"`
	PositionSeconds int32  `json:"position_seconds"`
	IsCompleted     bool   `json:"is_completed"`
}

func (q *Queries) InsertIncompleteWatchHistory(ctx context.Context, arg InsertIncompleteWatchHistoryParams) (WatchHistory, error) {
	row := q.db.QueryRowContext(ctx, insertIncompleteWatchHistory,
		arg.UserID,
		arg.ProgramID,
		arg.PositionSeconds,
		arg.IsCompleted,
	)
	var i WatchHistory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProgramID,
		&i.PositionSeconds,
		&i.IsCompleted,
		&i.LastWatchedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateIncompleteWatchHistory = `-- name: UpdateIncompleteWatchHistory :one
UPDATE watch_histories
SET
  position_seconds = $3,
  is_completed = $4,
  last_watched_at = now(),
  updated_at = now()
WHERE user_id = $1 AND program_id = $2 AND is_completed = FALSE
RETURNING id, user_id, program_id, position_seconds, is_completed, last_watched_at, created_at, updated_at
`

type UpdateIncompleteWatchHistoryParams struct {
	UserID          string `json:"user_id"`
	ProgramID       int64  `json:"program_id"`
	PositionSeconds int32  `json:"position_seconds"`
	IsCompleted     bool   `json:"is_completed"`
}

func (q *Queries) UpdateIncompleteWatchHistory(ctx context.Context, arg UpdateIncompleteWatchHistoryParams) (WatchHistory, error) {
	row := q.db.QueryRowContext(ctx, updateIncompleteWatchHistory,
		arg.UserID,
		arg.ProgramID,
		arg.PositionSeconds,
		arg.IsCompleted,
	)
	var i WatchHistory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProgramID,
		&i.PositionSeconds,
		&i.IsCompleted,
		&i.LastWatchedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertWatchHistory = `-- name: UpsertWatchHistory :one
WITH updated AS (
  UPDATE watch_histories AS wh
  SET
    position_seconds = $3,
    is_completed = $4,
    last_watched_at = now(),
    updated_at = now()
  WHERE wh.user_id = $1 AND wh.program_id = $2 AND wh.is_completed = FALSE
  RETURNING wh.id, wh.user_id, wh.program_id, wh.position_seconds, wh.is_completed, wh.last_watched_at, wh.created_at, wh.updated_at
),
inserted_incomplete AS (
  INSERT INTO watch_histories (
    user_id,
    program_id,
    position_seconds,
    is_completed,
    last_watched_at
  )
  SELECT $1, $2, $3, $4, now()
  WHERE $4 = FALSE
  ON CONFLICT (user_id, program_id) WHERE (is_completed = FALSE)
  DO UPDATE SET
    position_seconds = EXCLUDED.position_seconds,
    is_completed = EXCLUDED.is_completed,
    last_watched_at = now(),
    updated_at = now()
  RETURNING id, user_id, program_id, position_seconds, is_completed, last_watched_at, created_at, updated_at
),
inserted_completed AS (
  INSERT INTO watch_histories (
    user_id,
    program_id,
    position_seconds,
    is_completed,
    last_watched_at
  )
  SELECT $1, $2, $3, TRUE, now()
  WHERE $4 = TRUE AND NOT EXISTS (SELECT 1 FROM updated)
  RETURNING id, user_id, program_id, position_seconds, is_completed, last_watched_at, created_at, updated_at
)
SELECT id, user_id, program_id, position_seconds, is_completed, last_watched_at, created_at, updated_at FROM updated
UNION ALL
SELECT id, user_id, program_id, position_seconds, is_completed, last_watched_at, created_at, updated_at FROM inserted_incomplete
UNION ALL
SELECT id, user_id, program_id, position_seconds, is_completed, last_watched_at, created_at, updated_at FROM inserted_completed
LIMIT 1
`

type UpsertWatchHistoryParams struct {
	UserID          string `json:"user_id"`
	ProgramID       int64  `json:"program_id"`
	PositionSeconds int32  `json:"position_seconds"`
	IsCompleted     bool   `json:"is_completed"`
}

type UpsertWatchHistoryRow struct {
	ID              int64     `json:"id"`
	UserID          string    `json:"user_id"`
	ProgramID       int64     `json:"program_id"`
	PositionSeconds int32     `json:"position_seconds"`
	IsCompleted     bool      `json:"is_completed"`
	LastWatchedAt   time.Time `json:"last_watched_at"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
}

func (q *Queries) UpsertWatchHistory(ctx context.Context, arg UpsertWatchHistoryParams) (UpsertWatchHistoryRow, error) {
	row := q.db.QueryRowContext(ctx, upsertWatchHistory,
		arg.UserID,
		arg.ProgramID,
		arg.PositionSeconds,
		arg.IsCompleted,
	)
	var i UpsertWatchHistoryRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProgramID,
		&i.PositionSeconds,
		&i.IsCompleted,
		&i.LastWatchedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
