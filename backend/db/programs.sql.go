// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: programs.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const createProgram = `-- name: CreateProgram :one
INSERT INTO programs (
  title,
  video_path,
  thumbnail_path,
  description,
  is_limited_release,
  price
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING id, title, video_path, thumbnail_path, description, is_limited_release, price, created_at, updated_at
`

type CreateProgramParams struct {
	Title            string         `json:"title"`
	VideoPath        string         `json:"video_path"`
	ThumbnailPath    sql.NullString `json:"thumbnail_path"`
	Description      sql.NullString `json:"description"`
	IsLimitedRelease bool           `json:"is_limited_release"`
	Price            int32          `json:"price"`
}

type CreateProgramRow struct {
	ID               int64          `json:"id"`
	Title            string         `json:"title"`
	VideoPath        string         `json:"video_path"`
	ThumbnailPath    sql.NullString `json:"thumbnail_path"`
	Description      sql.NullString `json:"description"`
	IsLimitedRelease bool           `json:"is_limited_release"`
	Price            int32          `json:"price"`
	CreatedAt        time.Time      `json:"created_at"`
	UpdatedAt        time.Time      `json:"updated_at"`
}

func (q *Queries) CreateProgram(ctx context.Context, arg CreateProgramParams) (CreateProgramRow, error) {
	row := q.db.QueryRowContext(ctx, createProgram,
		arg.Title,
		arg.VideoPath,
		arg.ThumbnailPath,
		arg.Description,
		arg.IsLimitedRelease,
		arg.Price,
	)
	var i CreateProgramRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.VideoPath,
		&i.ThumbnailPath,
		&i.Description,
		&i.IsLimitedRelease,
		&i.Price,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const existsProgram = `-- name: ExistsProgram :one
SELECT EXISTS(
  SELECT 1
  FROM programs
  WHERE id = $1
) AS exists
`

func (q *Queries) ExistsProgram(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRowContext(ctx, existsProgram, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getProgramByID = `-- name: GetProgramByID :one
SELECT
  p.id AS program_id,
  p.title,
  p.video_path,
  p.thumbnail_path,
  p.description,
  p.view_count,
  p.is_limited_release,
  p.price,
  p.created_at AS program_created_at,
  p.updated_at AS program_updated_at,
  COALESCE(
    jsonb_agg(DISTINCT jsonb_build_object(
      'id', ct.id,
      'name', ct.name
    )) FILTER (WHERE ct.id IS NOT NULL),
    '[]'::jsonb
  ) AS category_tags,
  COALESCE(
    jsonb_agg(DISTINCT jsonb_build_object(
      'id', pe.id,
      'first_name', pe.first_name,
      'last_name', pe.last_name,
      'first_name_kana', pe.first_name_kana,
      'last_name_kana', pe.last_name_kana,
      'image_path', pe.image_path
    )) FILTER (WHERE pe.id IS NOT NULL),
    '[]'::jsonb
  ) AS performers
FROM programs p
LEFT JOIN program_category_tags pct ON p.id = pct.program_id
LEFT JOIN category_tags ct ON pct.tag_id = ct.id
LEFT JOIN program_performers pp ON p.id = pp.program_id
LEFT JOIN performers pe ON pp.performer_id = pe.id
WHERE p.id = $1 AND p.is_public = true
GROUP BY
  p.id,
  p.title,
  p.video_path,
  p.thumbnail_path,
  p.description,
  p.view_count,
  p.is_limited_release,
  p.price,
  p.created_at,
  p.updated_at
`

type GetProgramByIDRow struct {
	ProgramID        int64          `json:"program_id"`
	Title            string         `json:"title"`
	VideoPath        string         `json:"video_path"`
	ThumbnailPath    sql.NullString `json:"thumbnail_path"`
	Description      sql.NullString `json:"description"`
	ViewCount        int32          `json:"view_count"`
	IsLimitedRelease bool           `json:"is_limited_release"`
	Price            int32          `json:"price"`
	ProgramCreatedAt time.Time      `json:"program_created_at"`
	ProgramUpdatedAt time.Time      `json:"program_updated_at"`
	CategoryTags     interface{}    `json:"category_tags"`
	Performers       interface{}    `json:"performers"`
}

// 視聴回数はprogramsテーブルのview_countを参照
func (q *Queries) GetProgramByID(ctx context.Context, id int64) (GetProgramByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getProgramByID, id)
	var i GetProgramByIDRow
	err := row.Scan(
		&i.ProgramID,
		&i.Title,
		&i.VideoPath,
		&i.ThumbnailPath,
		&i.Description,
		&i.ViewCount,
		&i.IsLimitedRelease,
		&i.Price,
		&i.ProgramCreatedAt,
		&i.ProgramUpdatedAt,
		&i.CategoryTags,
		&i.Performers,
	)
	return i, err
}

const getProgramDetailsByID = `-- name: GetProgramDetailsByID :one
SELECT
  p.id AS program_id,
  p.title,
  p.video_path,
  p.thumbnail_path,
  p.description,
  p.view_count,
  p.is_limited_release,
  p.price,
  COALESCE((SELECT COUNT(*) FROM likes l WHERE l.program_id = p.id), 0)::bigint AS like_count,
  EXISTS(
    SELECT 1
    FROM likes l
    WHERE l.program_id = p.id AND l.user_id = $2
  ) AS liked,
  p.created_at AS program_created_at,
  p.updated_at AS program_updated_at,
  COALESCE(
    jsonb_agg(DISTINCT jsonb_build_object(
      'id', ct.id,
      'name', ct.name
    )) FILTER (WHERE ct.id IS NOT NULL),
    '[]'::jsonb
  ) AS category_tags,
  COALESCE(
    jsonb_agg(DISTINCT jsonb_build_object(
      'id', pe.id,
      'first_name', pe.first_name,
      'last_name', pe.last_name,
      'first_name_kana', pe.first_name_kana,
      'last_name_kana', pe.last_name_kana,
      'image_path', pe.image_path
    )) FILTER (WHERE pe.id IS NOT NULL),
    '[]'::jsonb
  ) AS performers
FROM programs p
LEFT JOIN program_category_tags pct ON p.id = pct.program_id
LEFT JOIN category_tags ct ON pct.tag_id = ct.id
LEFT JOIN program_performers pp ON p.id = pp.program_id
LEFT JOIN performers pe ON pp.performer_id = pe.id
WHERE p.id = $1 AND p.is_public = true
GROUP BY
  p.id,
  p.title,
  p.video_path,
  p.thumbnail_path,
  p.description,
  p.view_count,
  p.is_limited_release,
  p.price,
  p.created_at,
  p.updated_at
`

type GetProgramDetailsByIDParams struct {
	ID     int64  `json:"id"`
	UserID string `json:"user_id"`
}

type GetProgramDetailsByIDRow struct {
	ProgramID        int64          `json:"program_id"`
	Title            string         `json:"title"`
	VideoPath        string         `json:"video_path"`
	ThumbnailPath    sql.NullString `json:"thumbnail_path"`
	Description      sql.NullString `json:"description"`
	ViewCount        int32          `json:"view_count"`
	IsLimitedRelease bool           `json:"is_limited_release"`
	Price            int32          `json:"price"`
	LikeCount        int64          `json:"like_count"`
	Liked            bool           `json:"liked"`
	ProgramCreatedAt time.Time      `json:"program_created_at"`
	ProgramUpdatedAt time.Time      `json:"program_updated_at"`
	CategoryTags     interface{}    `json:"category_tags"`
	Performers       interface{}    `json:"performers"`
}

// 視聴回数はprogramsテーブルのview_countを参照
func (q *Queries) GetProgramDetailsByID(ctx context.Context, arg GetProgramDetailsByIDParams) (GetProgramDetailsByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getProgramDetailsByID, arg.ID, arg.UserID)
	var i GetProgramDetailsByIDRow
	err := row.Scan(
		&i.ProgramID,
		&i.Title,
		&i.VideoPath,
		&i.ThumbnailPath,
		&i.Description,
		&i.ViewCount,
		&i.IsLimitedRelease,
		&i.Price,
		&i.LikeCount,
		&i.Liked,
		&i.ProgramCreatedAt,
		&i.ProgramUpdatedAt,
		&i.CategoryTags,
		&i.Performers,
	)
	return i, err
}

const getPrograms = `-- name: GetPrograms :many
SELECT
  p.id AS program_id,
  p.title,
  p.thumbnail_path,
  p.view_count,
  p.is_limited_release,
  p.price,
  COALESCE((SELECT COUNT(*) FROM likes l WHERE l.program_id = p.id), 0)::bigint AS like_count,
  COALESCE(
    jsonb_agg(DISTINCT jsonb_build_object(
      'id', ct.id,
      'name', ct.name
    )) FILTER (WHERE ct.id IS NOT NULL),
    '[]'::jsonb
  ) AS category_tags
FROM programs p
LEFT JOIN program_category_tags pct ON p.id = pct.program_id
LEFT JOIN category_tags ct ON pct.tag_id = ct.id
WHERE
  p.is_public = true
  AND ($1::text IS NULL OR p.title ILIKE '%' || $1::text || '%')
  AND (
    $2::bigint[] IS NULL
    OR p.id IN (
      SELECT pct2.program_id
      FROM program_category_tags pct2
      WHERE pct2.tag_id = ANY($2::bigint[])
      GROUP BY pct2.program_id
      HAVING COUNT(DISTINCT pct2.tag_id) = array_length($2::bigint[], 1)
    )
  )
GROUP BY
  p.id,
  p.title,
  p.thumbnail_path,
  p.view_count,
  p.is_limited_release,
  p.price
`

type GetProgramsParams struct {
	Title  sql.NullString `json:"title"`
	TagIds []int64        `json:"tag_ids"`
}

type GetProgramsRow struct {
	ProgramID        int64          `json:"program_id"`
	Title            string         `json:"title"`
	ThumbnailPath    sql.NullString `json:"thumbnail_path"`
	ViewCount        int32          `json:"view_count"`
	IsLimitedRelease bool           `json:"is_limited_release"`
	Price            int32          `json:"price"`
	LikeCount        int64          `json:"like_count"`
	CategoryTags     interface{}    `json:"category_tags"`
}

// 視聴回数はprogramsテーブルのview_countを参照
func (q *Queries) GetPrograms(ctx context.Context, arg GetProgramsParams) ([]GetProgramsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPrograms, arg.Title, pq.Array(arg.TagIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProgramsRow
	for rows.Next() {
		var i GetProgramsRow
		if err := rows.Scan(
			&i.ProgramID,
			&i.Title,
			&i.ThumbnailPath,
			&i.ViewCount,
			&i.IsLimitedRelease,
			&i.Price,
			&i.LikeCount,
			&i.CategoryTags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopLikedPrograms = `-- name: GetTopLikedPrograms :many
WITH params AS (
  SELECT COALESCE($1::int, 7)::int AS n
),
top_likes AS (
  SELECT
    l.program_id,
    COUNT(*)::bigint AS like_count
  FROM likes l
  JOIN programs p ON l.program_id = p.id
  WHERE p.is_public = true
  GROUP BY l.program_id
  ORDER BY like_count DESC
  LIMIT (SELECT n FROM params)
),
fallback AS (
  SELECT
    p.id AS program_id,
    0::bigint AS like_count
  FROM programs p
  WHERE p.is_public = true AND p.id NOT IN (SELECT program_id FROM top_likes)
  ORDER BY p.created_at DESC
  LIMIT GREATEST((SELECT n FROM params) - (SELECT COUNT(*) FROM top_likes), 0)
),
selected AS (
  SELECT program_id, like_count FROM top_likes
  UNION ALL
  SELECT program_id, like_count FROM fallback
)
SELECT
  p.id AS program_id,
  p.title,
  p.thumbnail_path,
  p.view_count,
  p.is_limited_release,
  p.price,
  s.like_count
FROM selected s
JOIN programs p ON p.id = s.program_id
ORDER BY s.like_count DESC, p.created_at DESC
`

type GetTopLikedProgramsRow struct {
	ProgramID        int64          `json:"program_id"`
	Title            string         `json:"title"`
	ThumbnailPath    sql.NullString `json:"thumbnail_path"`
	ViewCount        int32          `json:"view_count"`
	IsLimitedRelease bool           `json:"is_limited_release"`
	Price            int32          `json:"price"`
	LikeCount        int64          `json:"like_count"`
}

func (q *Queries) GetTopLikedPrograms(ctx context.Context, limit sql.NullInt32) ([]GetTopLikedProgramsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopLikedPrograms, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopLikedProgramsRow
	for rows.Next() {
		var i GetTopLikedProgramsRow
		if err := rows.Scan(
			&i.ProgramID,
			&i.Title,
			&i.ThumbnailPath,
			&i.ViewCount,
			&i.IsLimitedRelease,
			&i.Price,
			&i.LikeCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopPrograms = `-- name: GetTopPrograms :many
SELECT
  p.id AS program_id,
  p.title,
  p.thumbnail_path,
  p.view_count,
  p.is_limited_release,
  p.price,
  COALESCE((SELECT COUNT(*) FROM likes l WHERE l.program_id = p.id), 0)::bigint AS like_count
FROM programs p
WHERE p.is_public = true
ORDER BY p.created_at DESC
LIMIT 7
`

type GetTopProgramsRow struct {
	ProgramID        int64          `json:"program_id"`
	Title            string         `json:"title"`
	ThumbnailPath    sql.NullString `json:"thumbnail_path"`
	ViewCount        int32          `json:"view_count"`
	IsLimitedRelease bool           `json:"is_limited_release"`
	Price            int32          `json:"price"`
	LikeCount        int64          `json:"like_count"`
}

// 視聴回数はprogramsテーブルのview_countを参照
func (q *Queries) GetTopPrograms(ctx context.Context) ([]GetTopProgramsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopPrograms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopProgramsRow
	for rows.Next() {
		var i GetTopProgramsRow
		if err := rows.Scan(
			&i.ProgramID,
			&i.Title,
			&i.ThumbnailPath,
			&i.ViewCount,
			&i.IsLimitedRelease,
			&i.Price,
			&i.LikeCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopViewedPrograms = `-- name: GetTopViewedPrograms :many
WITH likes_count AS (
  SELECT
    l.program_id,
    COUNT(*)::bigint AS like_count
  FROM likes l
  GROUP BY l.program_id
)
SELECT
  p.id AS program_id,
  p.title,
  p.thumbnail_path,
  p.view_count,
  p.is_limited_release,
  p.price,
  COALESCE(lc.like_count, 0)::bigint AS like_count
FROM programs p
LEFT JOIN likes_count lc ON lc.program_id = p.id
WHERE p.is_public = true
ORDER BY p.view_count DESC, p.created_at DESC
LIMIT COALESCE($1::int, 7)
`

type GetTopViewedProgramsRow struct {
	ProgramID        int64          `json:"program_id"`
	Title            string         `json:"title"`
	ThumbnailPath    sql.NullString `json:"thumbnail_path"`
	ViewCount        int32          `json:"view_count"`
	IsLimitedRelease bool           `json:"is_limited_release"`
	Price            int32          `json:"price"`
	LikeCount        int64          `json:"like_count"`
}

func (q *Queries) GetTopViewedPrograms(ctx context.Context, limit sql.NullInt32) ([]GetTopViewedProgramsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopViewedPrograms, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopViewedProgramsRow
	for rows.Next() {
		var i GetTopViewedProgramsRow
		if err := rows.Scan(
			&i.ProgramID,
			&i.Title,
			&i.ThumbnailPath,
			&i.ViewCount,
			&i.IsLimitedRelease,
			&i.Price,
			&i.LikeCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementProgramViewCount = `-- name: IncrementProgramViewCount :exec
UPDATE programs
SET view_count = view_count + 1
WHERE id = $1
`

func (q *Queries) IncrementProgramViewCount(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, incrementProgramViewCount, id)
	return err
}
