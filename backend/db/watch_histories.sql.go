// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: watch_histories.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const getIncompleteWatchHistoryByUserAndProgram = `-- name: GetIncompleteWatchHistoryByUserAndProgram :one
SELECT id, user_id, program_id, position_seconds, is_completed, last_watched_at, created_at, updated_at
FROM watch_histories
WHERE user_id = $1 AND program_id = $2 AND is_completed = FALSE
`

type GetIncompleteWatchHistoryByUserAndProgramParams struct {
	UserID    string `json:"user_id"`
	ProgramID int64  `json:"program_id"`
}

func (q *Queries) GetIncompleteWatchHistoryByUserAndProgram(ctx context.Context, arg GetIncompleteWatchHistoryByUserAndProgramParams) (WatchHistory, error) {
	row := q.db.QueryRowContext(ctx, getIncompleteWatchHistoryByUserAndProgram, arg.UserID, arg.ProgramID)
	var i WatchHistory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProgramID,
		&i.PositionSeconds,
		&i.IsCompleted,
		&i.LastWatchedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listWatchHistoriesByUser = `-- name: ListWatchHistoriesByUser :many
SELECT id, user_id, program_id, position_seconds, is_completed, last_watched_at, created_at, updated_at
FROM watch_histories
WHERE user_id = $1
ORDER BY last_watched_at DESC
LIMIT COALESCE($3::int, 50)
OFFSET COALESCE($2::int, 0)
`

type ListWatchHistoriesByUserParams struct {
	UserID string        `json:"user_id"`
	Offset sql.NullInt32 `json:"offset"`
	Limit  sql.NullInt32 `json:"limit"`
}

func (q *Queries) ListWatchHistoriesByUser(ctx context.Context, arg ListWatchHistoriesByUserParams) ([]WatchHistory, error) {
	rows, err := q.db.QueryContext(ctx, listWatchHistoriesByUser, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WatchHistory
	for rows.Next() {
		var i WatchHistory
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProgramID,
			&i.PositionSeconds,
			&i.IsCompleted,
			&i.LastWatchedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertWatchHistory = `-- name: UpsertWatchHistory :one
WITH updated AS (
  UPDATE watch_histories AS wh
  SET
    position_seconds = $3,
    is_completed = $4,
    last_watched_at = now(),
    updated_at = now()
  WHERE wh.user_id = $1 AND wh.program_id = $2 AND wh.is_completed = FALSE
  RETURNING wh.id, wh.user_id, wh.program_id, wh.position_seconds, wh.is_completed, wh.last_watched_at, wh.created_at, wh.updated_at
),
inserted_incomplete AS (
  INSERT INTO watch_histories (
    user_id,
    program_id,
    position_seconds,
    is_completed,
    last_watched_at
  )
  SELECT $1, $2, $3, $4, now()
  WHERE $4 = FALSE
  ON CONFLICT (user_id, program_id) WHERE (is_completed = FALSE)
  DO UPDATE SET
    position_seconds = EXCLUDED.position_seconds,
    is_completed = EXCLUDED.is_completed,
    last_watched_at = now(),
    updated_at = now()
  RETURNING id, user_id, program_id, position_seconds, is_completed, last_watched_at, created_at, updated_at
),
inserted_completed AS (
  INSERT INTO watch_histories (
    user_id,
    program_id,
    position_seconds,
    is_completed,
    last_watched_at
  )
  SELECT $1, $2, $3, TRUE, now()
  WHERE $4 = TRUE AND NOT EXISTS (SELECT 1 FROM updated)
  RETURNING id, user_id, program_id, position_seconds, is_completed, last_watched_at, created_at, updated_at
)
SELECT id, user_id, program_id, position_seconds, is_completed, last_watched_at, created_at, updated_at FROM updated
UNION ALL
SELECT id, user_id, program_id, position_seconds, is_completed, last_watched_at, created_at, updated_at FROM inserted_incomplete
UNION ALL
SELECT id, user_id, program_id, position_seconds, is_completed, last_watched_at, created_at, updated_at FROM inserted_completed
LIMIT 1
`

type UpsertWatchHistoryParams struct {
	UserID          string `json:"user_id"`
	ProgramID       int64  `json:"program_id"`
	PositionSeconds int32  `json:"position_seconds"`
	IsCompleted     bool   `json:"is_completed"`
}

type UpsertWatchHistoryRow struct {
	ID              int64     `json:"id"`
	UserID          string    `json:"user_id"`
	ProgramID       int64     `json:"program_id"`
	PositionSeconds int32     `json:"position_seconds"`
	IsCompleted     bool      `json:"is_completed"`
	LastWatchedAt   time.Time `json:"last_watched_at"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
}

func (q *Queries) UpsertWatchHistory(ctx context.Context, arg UpsertWatchHistoryParams) (UpsertWatchHistoryRow, error) {
	row := q.db.QueryRowContext(ctx, upsertWatchHistory,
		arg.UserID,
		arg.ProgramID,
		arg.PositionSeconds,
		arg.IsCompleted,
	)
	var i UpsertWatchHistoryRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProgramID,
		&i.PositionSeconds,
		&i.IsCompleted,
		&i.LastWatchedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
